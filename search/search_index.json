{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"amba-analysis-streams-api REST API for stream analysis platform","title":"Home"},{"location":"#amba-analysis-streams-api","text":"REST API for stream analysis platform","title":"amba-analysis-streams-api"},{"location":"main_ref/","text":"is_api_available () Checks if the api is running as expected. It returns 'ok' normally, if there is to little data in the last few minutes it will return 'not running' Source code in app/main.py @app . get ( \"/api/trend/available\" , response_description = \"available\" , summary = \"Check if api is available.\" ) def is_api_available (): \"\"\" Checks if the api is running as expected. It returns 'ok' normally, if there is to little data in the last few minutes it will return 'not running' \"\"\" return JSONResponse ( content = system_running_check ( query_api ))","title":"main"},{"location":"main_ref/#main.is_api_available","text":"Checks if the api is running as expected. It returns 'ok' normally, if there is to little data in the last few minutes it will return 'not running' Source code in app/main.py @app . get ( \"/api/trend/available\" , response_description = \"available\" , summary = \"Check if api is available.\" ) def is_api_available (): \"\"\" Checks if the api is running as expected. It returns 'ok' normally, if there is to little data in the last few minutes it will return 'not running' \"\"\" return JSONResponse ( content = system_running_check ( query_api ))","title":"is_api_available()"},{"location":"update_consumer_ref/","text":"","title":"update_consumer"},{"location":"daos/author_ref/","text":"","title":"author"},{"location":"daos/database_ref/","text":"","title":"database"},{"location":"daos/field_of_study_ref/","text":"","title":"field_of_study"},{"location":"daos/publication_ref/","text":"","title":"publication"},{"location":"daos/stats_ref/","text":"","title":"stats"},{"location":"models/schema/","text":"PublicationType ( str , Enum ) An enumeration.","title":"schema"},{"location":"models/schema/#models.schema.PublicationType","text":"An enumeration.","title":"PublicationType"},{"location":"routers/author_ref/","text":"get_author ( id , session = Depends ( get_session )) Get author data for a given id. it will also return the publication data of all publications in a given author. id : id of the author to get Source code in routers/author.py @router . get ( \"/get\" , summary = \"Get Author.\" , response_model = AmbaResponse ) def get_author ( id : int , session : Session = Depends ( get_session )): \"\"\" Get author data for a given id. it will also return the publication data of all publications in a given author. - **id**: id of the author to get \"\"\" start = time . time () item = retrieve_author ( session , id ) json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data }) get_authors_router ( offset = 0 , limit = 10 , sort = 'id' , order = 'asc' , search = '' , duration = 'currently' , session = Depends ( get_session )) Return authors data with added reduced publication data as json. This will not contain any trending or processed data. offset : offset limit : limit the result sort : field to use for sort order : 'asc' or 'desc' search : search keyword (title only) Source code in routers/author.py @router . get ( \"/\" , summary = \"Get Authors.\" , response_model = AmbaResponse ) def get_authors_router ( offset : int = 0 , limit : int = 10 , sort : str = 'id' , order : str = 'asc' , search : str = '' , duration : str = \"currently\" , session : Session = Depends ( get_session )): \"\"\" Return authors data with added reduced publication data as json. This will **not** contain any trending or processed data. - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort - **order**: 'asc' or 'desc' - **search**: search keyword (title only) \"\"\" start = time . time () json_compatible_item_data = get_authors ( session = session , offset = offset , limit = limit , sort = sort , order = order , duration = duration , search = search ) return { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data } get_trending_authors_router ( offset = 0 , limit = 10 , sort = 'score' , order = 'desc' , search = '' , duration = 'currently' , session = Depends ( get_session )) Return trending authors and their trending data for a given duration. offset : offset limit : limit the result sort : field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' order : 'asc' or 'desc' search : search keyword (title only) duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' Source code in routers/author.py @router . get ( \"/trending\" , summary = \"Get trending Authors.\" , response_model = AmbaResponse ) def get_trending_authors_router ( offset : int = 0 , limit : int = 10 , sort : str = 'score' , order : str = 'desc' , search : str = '' , duration : str = \"currently\" , session : Session = Depends ( get_session )): \"\"\" Return trending authors and their trending data for a given duration. - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' - **order**: 'asc' or 'desc' - **search**: search keyword (title only) - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' \"\"\" start = time . time () item = get_trending_authors ( session = session , offset = offset , limit = limit , sort = sort , order = order , duration = duration , search = search ) json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"author"},{"location":"routers/author_ref/#routers.author.get_author","text":"Get author data for a given id. it will also return the publication data of all publications in a given author. id : id of the author to get Source code in routers/author.py @router . get ( \"/get\" , summary = \"Get Author.\" , response_model = AmbaResponse ) def get_author ( id : int , session : Session = Depends ( get_session )): \"\"\" Get author data for a given id. it will also return the publication data of all publications in a given author. - **id**: id of the author to get \"\"\" start = time . time () item = retrieve_author ( session , id ) json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"get_author()"},{"location":"routers/author_ref/#routers.author.get_authors_router","text":"Return authors data with added reduced publication data as json. This will not contain any trending or processed data. offset : offset limit : limit the result sort : field to use for sort order : 'asc' or 'desc' search : search keyword (title only) Source code in routers/author.py @router . get ( \"/\" , summary = \"Get Authors.\" , response_model = AmbaResponse ) def get_authors_router ( offset : int = 0 , limit : int = 10 , sort : str = 'id' , order : str = 'asc' , search : str = '' , duration : str = \"currently\" , session : Session = Depends ( get_session )): \"\"\" Return authors data with added reduced publication data as json. This will **not** contain any trending or processed data. - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort - **order**: 'asc' or 'desc' - **search**: search keyword (title only) \"\"\" start = time . time () json_compatible_item_data = get_authors ( session = session , offset = offset , limit = limit , sort = sort , order = order , duration = duration , search = search ) return { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data }","title":"get_authors_router()"},{"location":"routers/author_ref/#routers.author.get_trending_authors_router","text":"Return trending authors and their trending data for a given duration. offset : offset limit : limit the result sort : field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' order : 'asc' or 'desc' search : search keyword (title only) duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' Source code in routers/author.py @router . get ( \"/trending\" , summary = \"Get trending Authors.\" , response_model = AmbaResponse ) def get_trending_authors_router ( offset : int = 0 , limit : int = 10 , sort : str = 'score' , order : str = 'desc' , search : str = '' , duration : str = \"currently\" , session : Session = Depends ( get_session )): \"\"\" Return trending authors and their trending data for a given duration. - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' - **order**: 'asc' or 'desc' - **search**: search keyword (title only) - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' \"\"\" start = time . time () item = get_trending_authors ( session = session , offset = offset , limit = limit , sort = sort , order = order , duration = duration , search = search ) json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"get_trending_authors_router()"},{"location":"routers/field_of_study_ref/","text":"get_field_of_study_data ( id , session = Depends ( get_session ), with_pubs = False ) Get field of study data for a given id. it will also return the publication data of all publications in a given field of study. id : id of the field of study to get Source code in routers/field_of_study.py @router . get ( \"/get\" , summary = \"Get Field of Study.\" , response_model = AmbaResponse ) def get_field_of_study_data ( id : int , session : Session = Depends ( get_session ), with_pubs : bool = False ): \"\"\" Get field of study data for a given id. it will also return the publication data of all publications in a given field of study. - **id**: id of the field of study to get \"\"\" start = time . time () item = retrieve_field_of_study ( session , id , with_pubs ) json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data }) get_fields_of_study_router ( offset = 0 , limit = 10 , sort = 'id' , order = 'asc' , search = '' , session = Depends ( get_session )) Return fields of study data with added reduced publication data as json. This will not contain any trending or processed data. offset : offset limit : limit the result sort : field to use for sort order : 'asc' or 'desc' search : search keyword (title only) Source code in routers/field_of_study.py @router . get ( \"/\" , summary = \"Get Fields of Study.\" , response_model = AmbaResponse ) def get_fields_of_study_router ( offset : int = 0 , limit : int = 10 , sort : str = 'id' , order : str = 'asc' , search : str = '' , session : Session = Depends ( get_session )): \"\"\" Return fields of study data with added reduced publication data as json. This will **not** contain any trending or processed data. - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort - **order**: 'asc' or 'desc' - **search**: search keyword (title only) \"\"\" start = time . time () json_compatible_item_data = get_fields_of_study ( session = session , offset = offset , limit = limit , sort = sort , order = order , search = search ) return { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data } get_trending_fields_of_study_router ( offset = 0 , limit = 10 , sort = 'score' , order = 'desc' , search = '' , duration = 'currently' , session = Depends ( get_session )) Return trending fields of study and their trending data for a given duration. offset : offset limit : limit the result sort : field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' order : 'asc' or 'desc' search : search keyword (title only) duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' Source code in routers/field_of_study.py @router . get ( \"/trending\" , summary = \"Get trending Fields of Study.\" , response_model = AmbaResponse ) def get_trending_fields_of_study_router ( offset : int = 0 , limit : int = 10 , sort : str = 'score' , order : str = 'desc' , search : str = '' , duration : str = \"currently\" , session : Session = Depends ( get_session )): \"\"\" Return trending fields of study and their trending data for a given duration. - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' - **order**: 'asc' or 'desc' - **search**: search keyword (title only) - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' \"\"\" start = time . time () item = get_trending_fields_of_study ( session = session , offset = offset , limit = limit , sort = sort , order = order , duration = duration , search = search ) json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"field_of_study"},{"location":"routers/field_of_study_ref/#routers.field_of_study.get_field_of_study_data","text":"Get field of study data for a given id. it will also return the publication data of all publications in a given field of study. id : id of the field of study to get Source code in routers/field_of_study.py @router . get ( \"/get\" , summary = \"Get Field of Study.\" , response_model = AmbaResponse ) def get_field_of_study_data ( id : int , session : Session = Depends ( get_session ), with_pubs : bool = False ): \"\"\" Get field of study data for a given id. it will also return the publication data of all publications in a given field of study. - **id**: id of the field of study to get \"\"\" start = time . time () item = retrieve_field_of_study ( session , id , with_pubs ) json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"get_field_of_study_data()"},{"location":"routers/field_of_study_ref/#routers.field_of_study.get_fields_of_study_router","text":"Return fields of study data with added reduced publication data as json. This will not contain any trending or processed data. offset : offset limit : limit the result sort : field to use for sort order : 'asc' or 'desc' search : search keyword (title only) Source code in routers/field_of_study.py @router . get ( \"/\" , summary = \"Get Fields of Study.\" , response_model = AmbaResponse ) def get_fields_of_study_router ( offset : int = 0 , limit : int = 10 , sort : str = 'id' , order : str = 'asc' , search : str = '' , session : Session = Depends ( get_session )): \"\"\" Return fields of study data with added reduced publication data as json. This will **not** contain any trending or processed data. - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort - **order**: 'asc' or 'desc' - **search**: search keyword (title only) \"\"\" start = time . time () json_compatible_item_data = get_fields_of_study ( session = session , offset = offset , limit = limit , sort = sort , order = order , search = search ) return { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data }","title":"get_fields_of_study_router()"},{"location":"routers/field_of_study_ref/#routers.field_of_study.get_trending_fields_of_study_router","text":"Return trending fields of study and their trending data for a given duration. offset : offset limit : limit the result sort : field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' order : 'asc' or 'desc' search : search keyword (title only) duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' Source code in routers/field_of_study.py @router . get ( \"/trending\" , summary = \"Get trending Fields of Study.\" , response_model = AmbaResponse ) def get_trending_fields_of_study_router ( offset : int = 0 , limit : int = 10 , sort : str = 'score' , order : str = 'desc' , search : str = '' , duration : str = \"currently\" , session : Session = Depends ( get_session )): \"\"\" Return trending fields of study and their trending data for a given duration. - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' - **order**: 'asc' or 'desc' - **search**: search keyword (title only) - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' \"\"\" start = time . time () item = get_trending_fields_of_study ( session = session , offset = offset , limit = limit , sort = sort , order = order , duration = duration , search = search ) json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"get_trending_fields_of_study_router()"},{"location":"routers/publication_ref/","text":"get_publication_data ( doi , duration = 'currently' , session = Depends ( get_session )) get publication data for a given doi doi : doi of the publication to get duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' Source code in routers/publication.py @router . get ( \"/get\" , summary = \"Get publication.\" , response_model = AmbaResponse ) def get_publication_data ( doi : str , duration : str = \"currently\" , session : Session = Depends ( get_session )): \"\"\" get publication data for a given doi - **doi**: doi of the publication to get - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' \"\"\" logging . warning ( 'retrieve publication ' + doi ) logging . warning ( 'retrieve publication ' + unquote ( doi )) start = time . time () publication = retrieve_publication ( session , doi , duration ) logging . warning ( publication ) json_compatible_item_data = jsonable_encoder ( publication ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data }) get_publications_router ( offset = 0 , limit = 10 , sort = 'id' , order = 'asc' , search = '' , session = Depends ( get_session )) Return publication data. This will not contain any trending or processed data. offset : offset limit : limit the result sort : field to use for sort order : 'asc' or 'desc' search : search keyword (title only) Source code in routers/publication.py @router . get ( \"/\" , summary = \"Get publications.\" , response_model = AmbaResponse ) def get_publications_router ( offset : int = 0 , limit : int = 10 , sort : str = 'id' , order : str = 'asc' , search : str = '' , session : Session = Depends ( get_session ) ): \"\"\" Return publication data. This will **not** contain any trending or processed data. - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort - **order**: 'asc' or 'desc' - **search**: search keyword (title only) \"\"\" start = time . time () json_compatible_item_data = get_publications ( session = session , offset = offset , limit = limit , sort = sort , order = order , search = search ) return { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data } get_trending_publications_for_author_router ( id , offset = 0 , limit = 10 , sort = 'score' , order = 'desc' , search = '' , duration = 'currently' , session = Depends ( get_session )) Return publications and their trending data for a given duration and author. id : authorId offset : offset limit : limit the result sort : field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' order : 'asc' or 'desc' search : search keyword (title only) duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' Source code in routers/publication.py @router . get ( \"/trending/author\" , summary = \"Get trending publications for a given author.\" , response_model = AmbaResponse ) def get_trending_publications_for_author_router ( id : int , offset : int = 0 , limit : int = 10 , sort : str = 'score' , order : str = 'desc' , search : str = '' , duration : str = \"currently\" , session : Session = Depends ( get_session ) ): \"\"\" Return publications and their trending data for a given duration and author. - **id**: authorId - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' - **order**: 'asc' or 'desc' - **search**: search keyword (title only) - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' \"\"\" start = time . time () item = get_trending_publications_for_author ( session = session , offset = offset , limit = limit , sort = sort , order = order , duration = duration , search = search , author_id = id ) json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data }) get_trending_publications_for_field_of_study_router ( id , offset = 0 , limit = 10 , sort = 'score' , order = 'desc' , search = '' , duration = 'currently' , session = Depends ( get_session )) Return publications and their trending data for a given duration and field of study. id : fieldOfStudyId offset : offset limit : limit the result sort : field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' order : 'asc' or 'desc' search : search keyword (title only) duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' Source code in routers/publication.py @router . get ( \"/trending/fieldOfScience\" , summary = \"Get trending publications for a given field of study.\" , response_model = AmbaResponse ) def get_trending_publications_for_field_of_study_router ( id : int , offset : int = 0 , limit : int = 10 , sort : str = 'score' , order : str = 'desc' , search : str = '' , duration : str = \"currently\" , session : Session = Depends ( get_session ) ): \"\"\" Return publications and their trending data for a given duration and field of study. - **id**: fieldOfStudyId - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' - **order**: 'asc' or 'desc' - **search**: search keyword (title only) - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' \"\"\" start = time . time () item = get_trending_publications_for_field_of_study ( session = session , offset = offset , limit = limit , sort = sort , order = order , duration = duration , search = search , fos_id = id ) json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data }) get_trending_publications_router ( offset = 0 , limit = 10 , sort = 'score' , order = 'desc' , search = '' , duration = 'currently' , session = Depends ( get_session )) Return publication trending data for a given duration. offset : offset limit : limit the result sort : field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' order : 'asc' or 'desc' search : search keyword (title only) duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' Source code in routers/publication.py @router . get ( \"/trending\" , summary = \"Get trending publications.\" , response_model = AmbaResponse ) def get_trending_publications_router ( offset : int = 0 , limit : int = 10 , sort : str = 'score' , order : str = 'desc' , search : str = '' , duration : str = \"currently\" , session : Session = Depends ( get_session ) ): \"\"\" Return publication trending data for a given duration. - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' - **order**: 'asc' or 'desc' - **search**: search keyword (title only) - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' \"\"\" start = time . time () item = get_trending_publications ( session = session , offset = offset , limit = limit , sort = sort , order = order , duration = duration , search = search ) json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"publication"},{"location":"routers/publication_ref/#routers.publication.get_publication_data","text":"get publication data for a given doi doi : doi of the publication to get duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' Source code in routers/publication.py @router . get ( \"/get\" , summary = \"Get publication.\" , response_model = AmbaResponse ) def get_publication_data ( doi : str , duration : str = \"currently\" , session : Session = Depends ( get_session )): \"\"\" get publication data for a given doi - **doi**: doi of the publication to get - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' \"\"\" logging . warning ( 'retrieve publication ' + doi ) logging . warning ( 'retrieve publication ' + unquote ( doi )) start = time . time () publication = retrieve_publication ( session , doi , duration ) logging . warning ( publication ) json_compatible_item_data = jsonable_encoder ( publication ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"get_publication_data()"},{"location":"routers/publication_ref/#routers.publication.get_publications_router","text":"Return publication data. This will not contain any trending or processed data. offset : offset limit : limit the result sort : field to use for sort order : 'asc' or 'desc' search : search keyword (title only) Source code in routers/publication.py @router . get ( \"/\" , summary = \"Get publications.\" , response_model = AmbaResponse ) def get_publications_router ( offset : int = 0 , limit : int = 10 , sort : str = 'id' , order : str = 'asc' , search : str = '' , session : Session = Depends ( get_session ) ): \"\"\" Return publication data. This will **not** contain any trending or processed data. - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort - **order**: 'asc' or 'desc' - **search**: search keyword (title only) \"\"\" start = time . time () json_compatible_item_data = get_publications ( session = session , offset = offset , limit = limit , sort = sort , order = order , search = search ) return { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data }","title":"get_publications_router()"},{"location":"routers/publication_ref/#routers.publication.get_trending_publications_for_author_router","text":"Return publications and their trending data for a given duration and author. id : authorId offset : offset limit : limit the result sort : field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' order : 'asc' or 'desc' search : search keyword (title only) duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' Source code in routers/publication.py @router . get ( \"/trending/author\" , summary = \"Get trending publications for a given author.\" , response_model = AmbaResponse ) def get_trending_publications_for_author_router ( id : int , offset : int = 0 , limit : int = 10 , sort : str = 'score' , order : str = 'desc' , search : str = '' , duration : str = \"currently\" , session : Session = Depends ( get_session ) ): \"\"\" Return publications and their trending data for a given duration and author. - **id**: authorId - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' - **order**: 'asc' or 'desc' - **search**: search keyword (title only) - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' \"\"\" start = time . time () item = get_trending_publications_for_author ( session = session , offset = offset , limit = limit , sort = sort , order = order , duration = duration , search = search , author_id = id ) json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"get_trending_publications_for_author_router()"},{"location":"routers/publication_ref/#routers.publication.get_trending_publications_for_field_of_study_router","text":"Return publications and their trending data for a given duration and field of study. id : fieldOfStudyId offset : offset limit : limit the result sort : field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' order : 'asc' or 'desc' search : search keyword (title only) duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' Source code in routers/publication.py @router . get ( \"/trending/fieldOfScience\" , summary = \"Get trending publications for a given field of study.\" , response_model = AmbaResponse ) def get_trending_publications_for_field_of_study_router ( id : int , offset : int = 0 , limit : int = 10 , sort : str = 'score' , order : str = 'desc' , search : str = '' , duration : str = \"currently\" , session : Session = Depends ( get_session ) ): \"\"\" Return publications and their trending data for a given duration and field of study. - **id**: fieldOfStudyId - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' - **order**: 'asc' or 'desc' - **search**: search keyword (title only) - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' \"\"\" start = time . time () item = get_trending_publications_for_field_of_study ( session = session , offset = offset , limit = limit , sort = sort , order = order , duration = duration , search = search , fos_id = id ) json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"get_trending_publications_for_field_of_study_router()"},{"location":"routers/publication_ref/#routers.publication.get_trending_publications_router","text":"Return publication trending data for a given duration. offset : offset limit : limit the result sort : field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' order : 'asc' or 'desc' search : search keyword (title only) duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' Source code in routers/publication.py @router . get ( \"/trending\" , summary = \"Get trending publications.\" , response_model = AmbaResponse ) def get_trending_publications_router ( offset : int = 0 , limit : int = 10 , sort : str = 'score' , order : str = 'desc' , search : str = '' , duration : str = \"currently\" , session : Session = Depends ( get_session ) ): \"\"\" Return publication trending data for a given duration. - **offset**: offset - **limit**: limit the result - **sort**: field to use for sort, available: 'score', 'count', 'mean_sentiment', 'sum_followers', 'abstract_difference', 'tweet_author_diversity', 'lan_diversity', 'location_diversity', 'mean_age', 'mean_length', 'avg_questions', 'avg_exclamations', 'projected_change' - **order**: 'asc' or 'desc' - **search**: search keyword (title only) - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' \"\"\" start = time . time () item = get_trending_publications ( session = session , offset = offset , limit = limit , sort = sort , order = order , duration = duration , search = search ) json_compatible_item_data = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"get_trending_publications_router()"},{"location":"routers/stats_ref/","text":"get_count_tweet_author ( doi = Query ( None ), mode = 'publication' , id = None , session = Depends ( get_session )) Get tweet author count. doi : (optional) only use the given doi mode : what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' id : needed for 'fieldOfStudy' or 'author' mode, the id of the entity Source code in routers/stats.py @router . get ( \"/countTweetAuthors\" , summary = \"Get tweet author count.\" , response_model = AmbaResponse ) def get_count_tweet_author ( doi : Optional [ str ] = Query ( None ), mode : str = \"publication\" , id : int = None , session : Session = Depends ( get_session )): \"\"\" Get tweet author count. - **doi**: (optional) only use the given doi - **mode**: what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' - **id**: needed for 'fieldOfStudy' or 'author' mode, the id of the entity \"\"\" start = time . time () json_compatible_item_data = get_tweet_author_count ( doi = doi , session = session , id = id , mode = mode ) # print(json_compatible_item_data) return { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data } get_numbers ( fields = Query ( None ), dois = Query ( None ), duration = 'currently' , mode = 'publication' , id = None , session = Depends ( get_session )) Query statistical numbers for publications. fields : list of strings with one of the following values, 'bot_rating', 'contains_abstract_raw', 'exclamations', 'followers', 'length', 'questions', 'score', 'sentiment_raw', \"count\" (default) dois : (optional) only use the given dois duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' mode : what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' id : needed for 'fieldOfStudy' or 'author' mode, the id of the entity Source code in routers/stats.py @router . get ( \"/numbers\" , summary = \"Get statistical numbers.\" , response_model = AmbaResponse ) def get_numbers ( fields : Optional [ List [ str ]] = Query ( None ), dois : Optional [ List [ str ]] = Query ( None ), duration : str = \"currently\" , mode : str = \"publication\" , id : int = None , session : Session = Depends ( get_session )): \"\"\" Query statistical numbers for publications. - **fields**: list of strings with one of the following values, 'bot_rating', 'contains_abstract_raw', 'exclamations', 'followers', 'length', 'questions', 'score', 'sentiment_raw', \"count\" (default) - **dois**: (optional) only use the given dois - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' - **mode**: what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' - **id**: needed for 'fieldOfStudy' or 'author' mode, the id of the entity \"\"\" start = time . time () if mode == \"fieldOfStudy\" and id : dois = get_dois_for_field_of_study ( id , session , duration ) if mode == \"author\" and id : dois = get_dois_for_author ( id , session , duration ) if not fields : fields = [ 'count' ] json_compatible_item_data = get_numbers_influx ( query_api = query_api , dois = dois , duration = duration , fields = fields ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data }) get_profile_information ( dois = Query ( None ), duration = 'currently' , mode = 'publication' , id = None , session = Depends ( get_session )) Return profile information meaning it will not only return the value of the doi, author or field of study but the avg, min and max to compare against. dois : (optional) only use the given dois duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' mode : what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' id : needed for 'fieldOfStudy' or 'author' mode, the id of the entity Source code in routers/stats.py @router . get ( \"/profile\" , summary = \"Get top profile information.\" , response_model = AmbaResponse ) def get_profile_information ( dois : Optional [ List [ str ]] = Query ( None ), duration : Optional [ str ] = \"currently\" , mode : str = \"publication\" , id : int = None , session : Session = Depends ( get_session )): \"\"\" Return profile information meaning it will not only return the value of the doi, author or field of study but the avg, min and max to compare against. - **dois**: (optional) only use the given dois - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' - **mode**: what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' - **id**: needed for 'fieldOfStudy' or 'author' mode, the id of the entity \"\"\" start = time . time () if ( mode == \"publication\" and not dois ) or ( mode == \"fieldOfStudy\" and not id ) or ( mode == \"author\" and not id ): raise HTTPException ( status_code = 404 , detail = \"Missing data.\" ) if mode == \"fieldOfStudy\" and id : # print('field of study ' + str(id)) dois = get_dois_for_field_of_study ( id , session , duration ) # print(dois) if mode == \"author\" and id : dois = get_dois_for_author ( id , session , duration ) if len ( dois ) == 0 : raise HTTPException ( status_code = 404 , detail = \"Missing data.\" ) doi_info = get_profile_information_for_doi ( query_api , dois , duration ) if mode == \"fieldOfStudy\" and id and doi_info : doi_info [ 'publication' ][ 'doi' ] = retrieve_field_of_study ( session , id )[ 'fields_of_study' ] if mode == \"author\" and id and doi_info : doi_info [ 'publication' ][ 'doi' ] = retrieve_author ( session , id )[ 'author' ] avg_info = get_profile_information_avg ( session , duration ) if doi_info and avg_info : json_compatible_item_data = jsonable_encoder ({ ** doi_info , ** avg_info }) else : json_compatible_item_data = {} return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data }) get_top_percentage_values ( fields = Query ( None ), doi = None , limit = 10 , min_percentage = 1 , session = Depends ( get_session )) Query accumulated top data numbers for publications with a percentage as well as a min percentage to filter out rare items. This query does not have a duration and will always return data collected over all time. fields : list of strings with one of the following values, 'entity', 'hashtag', 'lang', 'location', 'name', 'source', 'tweet_type', 'word' (default) doi : (optional) only use the given doi limit : (optional, 10) limits the result min_percentage : (optional, 1) limits the results to only items that have a higher or equal percentage Source code in routers/stats.py @router . get ( \"/top/percentages\" , summary = \"Get top numbers with percentage.\" , response_model = AmbaResponse ) def get_top_percentage_values ( fields : Optional [ List [ str ]] = Query ( None ), doi : Optional [ str ] = None , limit : int = 10 , min_percentage : float = 1 , session : Session = Depends ( get_session )): \"\"\" Query accumulated top data numbers for publications with a percentage as well as a min percentage to filter out rare items. This query does not have a duration and will always return data collected over all time. - **fields**: list of strings with one of the following values, 'entity', 'hashtag', 'lang', 'location', 'name', 'source', 'tweet_type', 'word' (default) - **doi**: (optional) only use the given doi - **limit**: (optional, 10) limits the result - **min_percentage**: (optional, 1) limits the results to only items that have a higher or equal percentage \"\"\" start = time . time () if not fields : fields = [ 'lang' ] json_compatible_item_data = {} for field in fields : item = get_discussion_data_list_with_percentage ( session = session , doi = doi , limit = limit , min_percentage = min_percentage , dd_type = field ) json_compatible_item_data [ field ] = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data }) get_top_values ( fields = Query ( None ), doi = None , limit = 10 , mode = 'publication' , id = None , session = Depends ( get_session )) Query accumulated top data numbers for publications. This query does not have a duration and will always return data collected over all time. fields : list of strings with one of the following values, 'entity', 'hashtag', 'lang', 'location', 'name', 'source', 'tweet_type', 'word' (default) doi : (optional) only use the given doi limit : (optional, 10) limits the result mode : what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' id : needed for 'fieldOfStudy' or 'author' mode, the id of the entity Source code in routers/stats.py @router . get ( \"/top\" , summary = \"Get top numbers.\" , response_model = AmbaResponse ) def get_top_values ( fields : Optional [ List [ str ]] = Query ( None ), doi : Optional [ str ] = None , limit : int = 10 , mode : str = \"publication\" , id : int = None , session : Session = Depends ( get_session )): \"\"\" Query accumulated top data numbers for publications. This query does not have a duration and will always return data collected over all time. - **fields**: list of strings with one of the following values, 'entity', 'hashtag', 'lang', 'location', 'name', 'source', 'tweet_type', 'word' (default) - **doi**: (optional) only use the given doi - **limit**: (optional, 10) limits the result - **mode**: what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' - **id**: needed for 'fieldOfStudy' or 'author' mode, the id of the entity \"\"\" start = time . time () if not fields : fields = [ 'word' ] json_compatible_item_data = {} for field in fields : item = get_discussion_data_list ( session = session , doi = doi , limit = limit , dd_type = field , id = id , mode = mode ) json_compatible_item_data [ field ] = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data }) get_trending_progress ( field = Query ( None ), n = 5 , duration = 'currently' , dois = Query ( None ), mode = 'publication' , id = None , session = Depends ( get_session )) Return the trending progress over time for a given field. It will either use the top n publications or a given doi list. field : list of strings with one of the following values: 'score' (default), 'count', 'mean_sentiment', 'sum_follower', 'abstract_difference', 'mean_age', 'mean_length', 'mean_questions', 'mean_exclamations', 'mean_bot_rating', 'projected_change', 'trending', 'ema', 'kama', 'ker', 'mean_score', 'stddev' n : if no dois given use the top n dois (based on the current duration) duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' dois : (optional) only use the given dois mode : what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' id : needed for 'fieldOfStudy' or 'author' mode, the id of the entity Source code in routers/stats.py @router . get ( \"/progress/trending\" , summary = \"Get progress from the trending bucket.\" , response_model = AmbaResponse ) def get_trending_progress ( field : Optional [ str ] = Query ( None ), n : Optional [ int ] = 5 , duration : Optional [ str ] = \"currently\" , dois : Optional [ List [ str ]] = Query ( None ), mode : str = \"publication\" , id : int = None , session : Session = Depends ( get_session )): \"\"\" Return the trending progress over time for a given field. It will either use the top n publications or a given doi list. - **field**: list of strings with one of the following values: 'score' (default), 'count', 'mean_sentiment', 'sum_follower', 'abstract_difference', 'mean_age', 'mean_length', 'mean_questions', 'mean_exclamations', 'mean_bot_rating', 'projected_change', 'trending', 'ema', 'kama', 'ker', 'mean_score', 'stddev' - **n**: if no dois given use the top n dois (based on the current duration) - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' - **dois**: (optional) only use the given dois - **mode**: what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' - **id**: needed for 'fieldOfStudy' or 'author' mode, the id of the entity \"\"\" start = time . time () if not field : field = 'score' if mode == \"fieldOfStudy\" and id : dois = get_dois_for_field_of_study ( id , session , duration ) if mode == \"author\" and id : dois = get_dois_for_author ( id , session , duration ) json_compatible_item_data = get_trending_chart_data ( query_api , session , duration , field , n , dois ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data }) get_tweets_discussion_data ( doi = Query ( None ), mode = 'publication' , id = None , session = Depends ( get_session )) Get the newest discussion data. doi : (optional) only use the given doi mode : what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' id : needed for 'fieldOfStudy' or 'author' mode, the id of the entity Source code in routers/stats.py @router . get ( \"/tweets\" , summary = \"Get newest discussion data.\" , response_model = AmbaResponse ) def get_tweets_discussion_data ( doi : Optional [ str ] = Query ( None ), mode : str = \"publication\" , id : int = None , session : Session = Depends ( get_session )): \"\"\" Get the newest discussion data. - **doi**: (optional) only use the given doi - **mode**: what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' - **id**: needed for 'fieldOfStudy' or 'author' mode, the id of the entity \"\"\" start = time . time () json_compatible_item_data = [ get_tweets ( doi = doi , session = session , id = id , mode = mode )] # print(json_compatible_item_data) return { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data } get_window_progress ( field = Query ( None ), n = 5 , duration = 'currently' , dois = Query ( None ), mode = 'publication' , id = None , session = Depends ( get_session )) Return the progress over time for a given field. It will either use the top n publications or a given doi list. Data will be aggregated in windows to optimize performance. field : list of strings with one of the following values: 'bot_rating', 'contains_abstract_raw', 'exclamations', 'followers', 'length', 'questions', 'score' (default), 'sentiment_raw', 'count' n : if no dois given use the top n dois (based on the current duration) duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' dois : (optional) only use the given dois mode : what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' id : needed for 'fieldOfStudy' or 'author' mode, the id of the entity Source code in routers/stats.py @router . get ( \"/progress/value\" , summary = \"Get progress for publications.\" , response_model = AmbaResponse ) def get_window_progress ( field : Optional [ str ] = Query ( None ), n : Optional [ int ] = 5 , duration : Optional [ str ] = \"currently\" , dois : Optional [ List [ str ]] = Query ( None ), mode : str = \"publication\" , id : int = None , session : Session = Depends ( get_session )): \"\"\" Return the progress over time for a given field. It will either use the top n publications or a given doi list. Data will be aggregated in windows to optimize performance. - **field**: list of strings with one of the following values: 'bot_rating', 'contains_abstract_raw', 'exclamations', 'followers', 'length', 'questions', 'score' (default), 'sentiment_raw', 'count' - **n**: if no dois given use the top n dois (based on the current duration) - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' - **dois**: (optional) only use the given dois - **mode**: what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' - **id**: needed for 'fieldOfStudy' or 'author' mode, the id of the entity \"\"\" start = time . time () if not field : field = 'score' if mode == \"fieldOfStudy\" and id : dois = get_dois_for_field_of_study ( id , session , duration ) if mode == \"author\" and id : dois = get_dois_for_author ( id , session , duration ) json_compatible_item_data = get_window_chart_data ( query_api , session , duration , field , n , dois ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"stats"},{"location":"routers/stats_ref/#routers.stats.get_count_tweet_author","text":"Get tweet author count. doi : (optional) only use the given doi mode : what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' id : needed for 'fieldOfStudy' or 'author' mode, the id of the entity Source code in routers/stats.py @router . get ( \"/countTweetAuthors\" , summary = \"Get tweet author count.\" , response_model = AmbaResponse ) def get_count_tweet_author ( doi : Optional [ str ] = Query ( None ), mode : str = \"publication\" , id : int = None , session : Session = Depends ( get_session )): \"\"\" Get tweet author count. - **doi**: (optional) only use the given doi - **mode**: what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' - **id**: needed for 'fieldOfStudy' or 'author' mode, the id of the entity \"\"\" start = time . time () json_compatible_item_data = get_tweet_author_count ( doi = doi , session = session , id = id , mode = mode ) # print(json_compatible_item_data) return { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data }","title":"get_count_tweet_author()"},{"location":"routers/stats_ref/#routers.stats.get_numbers","text":"Query statistical numbers for publications. fields : list of strings with one of the following values, 'bot_rating', 'contains_abstract_raw', 'exclamations', 'followers', 'length', 'questions', 'score', 'sentiment_raw', \"count\" (default) dois : (optional) only use the given dois duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' mode : what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' id : needed for 'fieldOfStudy' or 'author' mode, the id of the entity Source code in routers/stats.py @router . get ( \"/numbers\" , summary = \"Get statistical numbers.\" , response_model = AmbaResponse ) def get_numbers ( fields : Optional [ List [ str ]] = Query ( None ), dois : Optional [ List [ str ]] = Query ( None ), duration : str = \"currently\" , mode : str = \"publication\" , id : int = None , session : Session = Depends ( get_session )): \"\"\" Query statistical numbers for publications. - **fields**: list of strings with one of the following values, 'bot_rating', 'contains_abstract_raw', 'exclamations', 'followers', 'length', 'questions', 'score', 'sentiment_raw', \"count\" (default) - **dois**: (optional) only use the given dois - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' - **mode**: what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' - **id**: needed for 'fieldOfStudy' or 'author' mode, the id of the entity \"\"\" start = time . time () if mode == \"fieldOfStudy\" and id : dois = get_dois_for_field_of_study ( id , session , duration ) if mode == \"author\" and id : dois = get_dois_for_author ( id , session , duration ) if not fields : fields = [ 'count' ] json_compatible_item_data = get_numbers_influx ( query_api = query_api , dois = dois , duration = duration , fields = fields ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"get_numbers()"},{"location":"routers/stats_ref/#routers.stats.get_profile_information","text":"Return profile information meaning it will not only return the value of the doi, author or field of study but the avg, min and max to compare against. dois : (optional) only use the given dois duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' mode : what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' id : needed for 'fieldOfStudy' or 'author' mode, the id of the entity Source code in routers/stats.py @router . get ( \"/profile\" , summary = \"Get top profile information.\" , response_model = AmbaResponse ) def get_profile_information ( dois : Optional [ List [ str ]] = Query ( None ), duration : Optional [ str ] = \"currently\" , mode : str = \"publication\" , id : int = None , session : Session = Depends ( get_session )): \"\"\" Return profile information meaning it will not only return the value of the doi, author or field of study but the avg, min and max to compare against. - **dois**: (optional) only use the given dois - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' - **mode**: what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' - **id**: needed for 'fieldOfStudy' or 'author' mode, the id of the entity \"\"\" start = time . time () if ( mode == \"publication\" and not dois ) or ( mode == \"fieldOfStudy\" and not id ) or ( mode == \"author\" and not id ): raise HTTPException ( status_code = 404 , detail = \"Missing data.\" ) if mode == \"fieldOfStudy\" and id : # print('field of study ' + str(id)) dois = get_dois_for_field_of_study ( id , session , duration ) # print(dois) if mode == \"author\" and id : dois = get_dois_for_author ( id , session , duration ) if len ( dois ) == 0 : raise HTTPException ( status_code = 404 , detail = \"Missing data.\" ) doi_info = get_profile_information_for_doi ( query_api , dois , duration ) if mode == \"fieldOfStudy\" and id and doi_info : doi_info [ 'publication' ][ 'doi' ] = retrieve_field_of_study ( session , id )[ 'fields_of_study' ] if mode == \"author\" and id and doi_info : doi_info [ 'publication' ][ 'doi' ] = retrieve_author ( session , id )[ 'author' ] avg_info = get_profile_information_avg ( session , duration ) if doi_info and avg_info : json_compatible_item_data = jsonable_encoder ({ ** doi_info , ** avg_info }) else : json_compatible_item_data = {} return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"get_profile_information()"},{"location":"routers/stats_ref/#routers.stats.get_top_percentage_values","text":"Query accumulated top data numbers for publications with a percentage as well as a min percentage to filter out rare items. This query does not have a duration and will always return data collected over all time. fields : list of strings with one of the following values, 'entity', 'hashtag', 'lang', 'location', 'name', 'source', 'tweet_type', 'word' (default) doi : (optional) only use the given doi limit : (optional, 10) limits the result min_percentage : (optional, 1) limits the results to only items that have a higher or equal percentage Source code in routers/stats.py @router . get ( \"/top/percentages\" , summary = \"Get top numbers with percentage.\" , response_model = AmbaResponse ) def get_top_percentage_values ( fields : Optional [ List [ str ]] = Query ( None ), doi : Optional [ str ] = None , limit : int = 10 , min_percentage : float = 1 , session : Session = Depends ( get_session )): \"\"\" Query accumulated top data numbers for publications with a percentage as well as a min percentage to filter out rare items. This query does not have a duration and will always return data collected over all time. - **fields**: list of strings with one of the following values, 'entity', 'hashtag', 'lang', 'location', 'name', 'source', 'tweet_type', 'word' (default) - **doi**: (optional) only use the given doi - **limit**: (optional, 10) limits the result - **min_percentage**: (optional, 1) limits the results to only items that have a higher or equal percentage \"\"\" start = time . time () if not fields : fields = [ 'lang' ] json_compatible_item_data = {} for field in fields : item = get_discussion_data_list_with_percentage ( session = session , doi = doi , limit = limit , min_percentage = min_percentage , dd_type = field ) json_compatible_item_data [ field ] = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"get_top_percentage_values()"},{"location":"routers/stats_ref/#routers.stats.get_top_values","text":"Query accumulated top data numbers for publications. This query does not have a duration and will always return data collected over all time. fields : list of strings with one of the following values, 'entity', 'hashtag', 'lang', 'location', 'name', 'source', 'tweet_type', 'word' (default) doi : (optional) only use the given doi limit : (optional, 10) limits the result mode : what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' id : needed for 'fieldOfStudy' or 'author' mode, the id of the entity Source code in routers/stats.py @router . get ( \"/top\" , summary = \"Get top numbers.\" , response_model = AmbaResponse ) def get_top_values ( fields : Optional [ List [ str ]] = Query ( None ), doi : Optional [ str ] = None , limit : int = 10 , mode : str = \"publication\" , id : int = None , session : Session = Depends ( get_session )): \"\"\" Query accumulated top data numbers for publications. This query does not have a duration and will always return data collected over all time. - **fields**: list of strings with one of the following values, 'entity', 'hashtag', 'lang', 'location', 'name', 'source', 'tweet_type', 'word' (default) - **doi**: (optional) only use the given doi - **limit**: (optional, 10) limits the result - **mode**: what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' - **id**: needed for 'fieldOfStudy' or 'author' mode, the id of the entity \"\"\" start = time . time () if not fields : fields = [ 'word' ] json_compatible_item_data = {} for field in fields : item = get_discussion_data_list ( session = session , doi = doi , limit = limit , dd_type = field , id = id , mode = mode ) json_compatible_item_data [ field ] = jsonable_encoder ( item ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"get_top_values()"},{"location":"routers/stats_ref/#routers.stats.get_trending_progress","text":"Return the trending progress over time for a given field. It will either use the top n publications or a given doi list. field : list of strings with one of the following values: 'score' (default), 'count', 'mean_sentiment', 'sum_follower', 'abstract_difference', 'mean_age', 'mean_length', 'mean_questions', 'mean_exclamations', 'mean_bot_rating', 'projected_change', 'trending', 'ema', 'kama', 'ker', 'mean_score', 'stddev' n : if no dois given use the top n dois (based on the current duration) duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' dois : (optional) only use the given dois mode : what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' id : needed for 'fieldOfStudy' or 'author' mode, the id of the entity Source code in routers/stats.py @router . get ( \"/progress/trending\" , summary = \"Get progress from the trending bucket.\" , response_model = AmbaResponse ) def get_trending_progress ( field : Optional [ str ] = Query ( None ), n : Optional [ int ] = 5 , duration : Optional [ str ] = \"currently\" , dois : Optional [ List [ str ]] = Query ( None ), mode : str = \"publication\" , id : int = None , session : Session = Depends ( get_session )): \"\"\" Return the trending progress over time for a given field. It will either use the top n publications or a given doi list. - **field**: list of strings with one of the following values: 'score' (default), 'count', 'mean_sentiment', 'sum_follower', 'abstract_difference', 'mean_age', 'mean_length', 'mean_questions', 'mean_exclamations', 'mean_bot_rating', 'projected_change', 'trending', 'ema', 'kama', 'ker', 'mean_score', 'stddev' - **n**: if no dois given use the top n dois (based on the current duration) - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' - **dois**: (optional) only use the given dois - **mode**: what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' - **id**: needed for 'fieldOfStudy' or 'author' mode, the id of the entity \"\"\" start = time . time () if not field : field = 'score' if mode == \"fieldOfStudy\" and id : dois = get_dois_for_field_of_study ( id , session , duration ) if mode == \"author\" and id : dois = get_dois_for_author ( id , session , duration ) json_compatible_item_data = get_trending_chart_data ( query_api , session , duration , field , n , dois ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"get_trending_progress()"},{"location":"routers/stats_ref/#routers.stats.get_tweets_discussion_data","text":"Get the newest discussion data. doi : (optional) only use the given doi mode : what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' id : needed for 'fieldOfStudy' or 'author' mode, the id of the entity Source code in routers/stats.py @router . get ( \"/tweets\" , summary = \"Get newest discussion data.\" , response_model = AmbaResponse ) def get_tweets_discussion_data ( doi : Optional [ str ] = Query ( None ), mode : str = \"publication\" , id : int = None , session : Session = Depends ( get_session )): \"\"\" Get the newest discussion data. - **doi**: (optional) only use the given doi - **mode**: what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' - **id**: needed for 'fieldOfStudy' or 'author' mode, the id of the entity \"\"\" start = time . time () json_compatible_item_data = [ get_tweets ( doi = doi , session = session , id = id , mode = mode )] # print(json_compatible_item_data) return { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data }","title":"get_tweets_discussion_data()"},{"location":"routers/stats_ref/#routers.stats.get_window_progress","text":"Return the progress over time for a given field. It will either use the top n publications or a given doi list. Data will be aggregated in windows to optimize performance. field : list of strings with one of the following values: 'bot_rating', 'contains_abstract_raw', 'exclamations', 'followers', 'length', 'questions', 'score' (default), 'sentiment_raw', 'count' n : if no dois given use the top n dois (based on the current duration) duration : the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' dois : (optional) only use the given dois mode : what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' id : needed for 'fieldOfStudy' or 'author' mode, the id of the entity Source code in routers/stats.py @router . get ( \"/progress/value\" , summary = \"Get progress for publications.\" , response_model = AmbaResponse ) def get_window_progress ( field : Optional [ str ] = Query ( None ), n : Optional [ int ] = 5 , duration : Optional [ str ] = \"currently\" , dois : Optional [ List [ str ]] = Query ( None ), mode : str = \"publication\" , id : int = None , session : Session = Depends ( get_session )): \"\"\" Return the progress over time for a given field. It will either use the top n publications or a given doi list. Data will be aggregated in windows to optimize performance. - **field**: list of strings with one of the following values: 'bot_rating', 'contains_abstract_raw', 'exclamations', 'followers', 'length', 'questions', 'score' (default), 'sentiment_raw', 'count' - **n**: if no dois given use the top n dois (based on the current duration) - **duration**: the duration of data that should be queried, 'currently' (default), 'today', 'week', 'month', 'year' - **dois**: (optional) only use the given dois - **mode**: what mode should be used, can be: 'publication' (default), 'fieldOfStudy' or 'author' - **id**: needed for 'fieldOfStudy' or 'author' mode, the id of the entity \"\"\" start = time . time () if not field : field = 'score' if mode == \"fieldOfStudy\" and id : dois = get_dois_for_field_of_study ( id , session , duration ) if mode == \"author\" and id : dois = get_dois_for_author ( id , session , duration ) json_compatible_item_data = get_window_chart_data ( query_api , session , duration , field , n , dois ) return JSONResponse ( content = { \"time\" : round (( time . time () - start ) * 1000 ), \"results\" : json_compatible_item_data })","title":"get_window_progress()"}]}